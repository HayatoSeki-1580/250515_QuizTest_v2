<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>社内学習ブラウザ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Ensure Inter font is loaded, Tailwind uses it by default */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom styles */
        /* Style for options */
        .option-label {
            display: block;
            margin-bottom: 0.75rem; /* 12px */
            padding: 0.75rem; /* 12px */
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.375rem; /* 6px */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: #ffffff; /* white */
        }

        /* Allow pointer cursor only when not answered */
        #options-container:not(.answered) .option-label {
            cursor: pointer;
        }

        #options-container:not(.answered) .option-label:hover {
            background-color: #f3f4f6; /* gray-100 */
            border-color: #9ca3af; /* gray-400 */
        }

        /* Style for selected option (before checking) */
        #options-container:not(.answered) .option-label input[type="radio"]:checked + .option-text-span {
            font-weight: 500; /* medium */
            color: #1e40af; /* blue-800 */
        }

        /* Style for selected option (before checking) - parent label style */
        #options-container:not(.answered) .option-label input[type="radio"]:checked + .option-text-span::before {
            content: '▶ ';
            color: #2563eb; /* blue-600 */
        }

        /* Style for correct answer */
        .option-label.correct-answer {
            background-color: #d1fae5; /* green-100 */
            border-color: #34d399; /* green-400 */
            font-weight: bold;
        }

        /* Style for incorrect answer selected by user */
        .option-label.incorrect-answer {
            background-color: #fee2e2; /* red-100 */
            border-color: #f87171; /* red-400 */
        }

        /* Style for non-selected options after answer */
        #options-container.answered .option-label:not(.correct-answer):not(.incorrect-answer) {
            opacity: 0.6;
        }

        /* Hide default radio button */
        .option-label input[type="radio"] {
            display: none;
        }

        /* Style for result message */
        .result {
            margin-top: 1.25rem; /* 20px */
            padding: 0.75rem; /* 12px */
            border-radius: 0.375rem; /* 6px */
            font-weight: bold;
            min-height: 1.5em; /* Ensure space even if empty */
        }

        .result.correct {
            background-color: #d1fae5; /* green-100 */
            color: #065f46; /* green-800 */
            border: 1px solid #a7f3d0; /* green-200 */
        }

        .result.incorrect {
            background-color: #fee2e2; /* red-100 */
            color: #991b1b; /* red-800 */
            border: 1px solid #fecaca; /* red-200 */
        }

        /* Style for incorrect list items */
        #incorrect-list li {
            background-color: #fef2f2; /* red-50 */
            border: 1px solid #fecaca; /* red-200 */
            border-radius: 0.25rem; /* 4px */
            padding: 0.75rem; /* 12px */
            margin-bottom: 0.5rem; /* 8px */
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #incorrect-list li:hover {
            background-color: #fee2e2; /* red-100 */
        }
        #incorrect-list li strong {
            color: #b91c1c; /* red-700 */
        }

        /* Progress bar styles */
        #progress-bar-container {
            width: 100%;
            background-color: #e5e7eb; /* gray-200 */
            border-radius: 9999px; /* full */
            height: 8px; /* h-2 */
            margin-bottom: 1.5rem; /* 24px */
            overflow: hidden; /* Ensure inner bar respects rounded corners */
        }

        #progress-bar {
            height: 100%;
            width: 0%; /* Initial width */
            background-color: #3b82f6; /* blue-500 */
            border-radius: 9999px; /* full */
            transition: width 0.5s ease-in-out;
        }

        /* Styles for formatted question items */
        .question-items-container {
            margin-top: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.375rem; /* rounded-md */
            overflow: hidden; /* For rounded corners on children */
        }

        .question-item, .question-items-header {
            display: grid;
            grid-template-columns: 2rem 2rem 12rem 1fr; /* Adjust as needed */
            gap: 0.5rem; /* gap-2 */
            padding: 0.75rem; /* p-3 */
            border-bottom: 1px solid #e5e7eb; /* gray-200 */
            align-items: center; /* vertical alignment */
        }

        .question-item:last-child {
            border-bottom: none; /* Remove border for the last item */
        }

        .question-item .item-label {
            font-weight: bold;
            grid-column: 2 / 3; /* Place in the second column */
        }

        .question-item .item-quantity {
            grid-column: 3 / 4; /* Place in the third column */
        }

        .question-item .item-unit {
            grid-column: 4 / 5; /* Place in the fourth column */
        }

        .question-items-header {
            font-weight: bold;
            background-color: #f9fafb; /* gray-50 */
            border-bottom: 1px solid #d1d5db; /* gray-300 */
            grid-template-columns: 2rem 2rem 12rem 1fr; /* Must match .question-item */
        }

        .question-items-header .header-quantity {
            grid-column: 3 / 4; /* Align with item-quantity */
        }

        .question-items-header .header-unit {
            grid-column: 4 / 5; /* Align with item-unit */
        }

        @media (max-width: 600px) {
            .question-item, .question-items-header {
                grid-template-columns: 1.5rem 1.5rem 8rem 1fr; /* Narrower columns */
                gap: 0.3rem;
                padding: 0.5rem;
            }
            .question-item .item-quantity {
                grid-column: 3 / 4;
            }
            .question-item .item-unit {
                grid-column: 4 / 5;
            }
            .question-items-header .header-quantity {
                grid-column: 3 / 4;
            }
            .question-items-header .header-unit {
                grid-column: 4 / 5;
            }
        }

        /* Styles for mode selection and year list */
        #mode-selection-container, #year-list-container, #question-list-container {
            display: none; /* Initially hidden, controlled by JS */
            text-align: center;
        }

        .mode-button, .year-button, .question-list-item {
            display: block;
            width: 100%;
            padding: 1rem;
            margin-bottom: 1rem;
            font-size: 1.25rem;
            font-weight: 600;
            color: #ffffff;
            background-color: #3b82f6; /* blue-500 */
            border-radius: 0.375rem; /* rounded-md */
            cursor: pointer;
            transition: background-color 0.3s ease;
            text-align: center;
        }

        .mode-button:hover, .year-button:hover, .question-list-item:hover {
            background-color: #2563eb; /* blue-600 */
        }

        .year-button {
            background-color: #10b981; /* green-500 */
        }

        .year-button:hover {
            background-color: #059669; /* green-600 */
        }

        .question-list-item {
            background-color: #60a5fa; /* blue-400 */
            font-size: 1rem;
            text-align: left;
            display: flex; /* Use flexbox for better alignment */
            align-items: center;
            justify-content: space-between; /* Space out content and status */
        }

        .question-list-item:hover {
            background-color: #3b82f6; /* blue-500 */
        }

        .question-list-item .status-indicator {
            font-weight: bold;
            margin-left: 1rem; /* Space from text */
        }

        .question-list-item.answered .status-indicator {
            color: #4b5563; /* gray-600 */
        }

        .question-list-item.correct .status-indicator {
            color: #059669; /* green-600 */
        }

        .question-list-item.incorrect .status-indicator {
            color: #dc2626; /* red-600 */
        }

        #question-list-container h3 {
            font-size: 1.5rem;
            color: #1e40af; /* blue-800 */
            margin-bottom: 1.5rem;
        }

        .back-button {
            margin-top: 1.5rem;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            color: #ffffff;
            background-color: #6b7280; /* gray-500 */
            border-radius: 0.375rem; /* rounded-md */
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .back-button:hover {
            background-color: #4b5563; /* gray-600 */
        }

        #question-count {
            font-size: 1rem;
            font-weight: bold;
            color: #4b5563; /* gray-600 */
            margin-bottom: 0.5rem; /* space between count and title */
            display: block; /* Ensure it takes its own line */
        }
    </style>
</head>
<body class="bg-gray-100 flex justify-center items-start min-h-screen py-8 px-4">

    <div id="quiz-container" class="bg-white p-8 rounded-lg shadow-xl max-w-xl w-full">

        <div id="mode-selection-container">
            <h2 class="text-2xl text-blue-700 mb-6">学習モード選択</h2>
            <button id="random-mode-button" class="mode-button">ランダム出題開始 (5問)</button>
            <button id="year-select-mode-button" class="mode-button">年度を選択して学習</button>
        </div>

        <div id="year-list-container">
            <h2 class="text-2xl text-blue-700 mb-6">年度選択</h2>
            <div id="year-buttons-container">
            </div>
            <button id="back-to-mode-select-button" class="back-button">モード選択に戻る</button>
        </div>

        <div id="question-list-container">
            <h3 id="selected-year-title"></h3>
            <div id="questions-for-year-container">
            </div>
            <button id="back-to-year-select-button" class="back-button">年度選択に戻る</button>
        </div>

        <div id="question-container">
            <div id="progress-bar-container">
                <div id="progress-bar"></div>
            </div>
            <span id="question-count" style="display: none;"></span>
            <h2 id="question-title" class="text-xl md:text-2xl text-blue-700 mb-4 pb-2 border-b-2 border-blue-700"></h2>
            <div id="question-text" class="mb-6 whitespace-pre-wrap text-gray-800"></div>
            <div id="options-container">
            </div>
            <div id="result" class="result"></div>
            <div class="mt-6 flex flex-col md:flex-row justify-center gap-4">
                <button id="next-button" class="px-6 py-3 text-lg font-semibold text-white bg-green-600 hover:bg-green-700 rounded-md cursor-pointer transition-colors duration-300 w-full md:w-auto" style="display: none;">次の問題へ</button>
                <button id="back-to-previous-screen-button" class="px-6 py-3 text-lg font-semibold text-white bg-gray-600 hover:bg-gray-700 rounded-md cursor-pointer transition-colors duration-300 w-full md:w-auto" style="display: none;">戻る</button>
            </div>
        </div>

        <div id="quiz-end-message" class="mt-8 text-center" style="display: none;">
            <h2 class="text-2xl text-blue-700 mb-4">クイズ終了！</h2>
            <p id="final-score" class="text-xl mb-5 font-semibold"></p>
            <div id="incorrect-list-container" class="mt-8 text-left border-t pt-5">
            </div>
            <button id="reset-button" class="mt-6 px-6 py-3 text-lg font-semibold text-gray-800 bg-yellow-400 hover:bg-yellow-500 rounded-md cursor-pointer transition-colors duration-300 w-full md:w-auto">もう一度挑戦する</button>
        </div>
    </div>

    <script>
        // グローバルスコープに配置するデータと定数
        let allQuizData = []; // JSONから読み込む全クイズデータ
        const NUMBER_OF_QUESTIONS_TO_ASK_RANDOM = 5; // ランダム出題時の問題数

        // クイズの状態を管理するオブジェクト
        let quizState = {
            currentMode: 'select', // 'select', 'random', 'year_select', 'question_list', 'quiz', 'end'
            questions: [], // 現在のクイズセッションで使われる問題の配列
            currentQuestionIndex: -1,
            currentQuestionObject: null, // 現在表示中の問題オブジェクト (特にレビュー時などに使用)
            correctAnswers: 0,
            incorrectQuestions: [], // ランダムモードで間違えた問題のリスト
            answered: false,
            currentYear: null, // 年度選択モードで選択された年度
            previousScreen: 'select' // 「戻る」ボタンのための前の画面情報
        };

        // DOM要素の取得 (グローバルで一度だけ行う)
        const domElements = {};

        function cacheDOMElements() {
            domElements.quizContainer = document.getElementById('quiz-container');
            domElements.modeSelectionContainer = document.getElementById('mode-selection-container');
            domElements.yearListContainer = document.getElementById('year-list-container');
            domElements.questionListContainer = document.getElementById('question-list-container');
            domElements.questionContainer = document.getElementById('question-container');
            domElements.questionCountSpan = document.getElementById('question-count');
            domElements.questionTitle = document.getElementById('question-title');
            domElements.questionTextDiv = document.getElementById('question-text');
            domElements.optionsContainer = document.getElementById('options-container');
            domElements.resultDiv = document.getElementById('result');
            domElements.nextButton = document.getElementById('next-button');
            domElements.backToPreviousScreenButton = document.getElementById('back-to-previous-screen-button');
            domElements.quizEndMessage = document.getElementById('quiz-end-message');
            domElements.finalScore = document.getElementById('final-score');
            domElements.resetButton = document.getElementById('reset-button');
            domElements.incorrectListContainer = document.getElementById('incorrect-list-container');
            domElements.progressBar = document.getElementById('progress-bar');
            domElements.progressBarContainer = document.getElementById('progress-bar-container');
            domElements.randomModeButton = document.getElementById('random-mode-button');
            domElements.yearSelectModeButton = document.getElementById('year-select-mode-button');
            domElements.yearButtonsContainer = document.getElementById('year-buttons-container');
            domElements.backToModeSelectButton = document.getElementById('back-to-mode-select-button');
            domElements.selectedYearTitle = document.getElementById('selected-year-title');
            domElements.questionsForYearContainer = document.getElementById('questions-for-year-container');
            domElements.backToYearSelectButton = document.getElementById('back-to-year-select-button');

            for (const key in domElements) {
                if (!domElements[key] && key !== 'progressBar') {
                    if(key === 'progressBarContainer' && !domElements.progressBar) { /* progressBarContainer implies progressBar */ }
                    else if (key === 'progressBar' && !domElements.progressBarContainer) { /* progressBar implies progressBarContainer */ }
                    else {
                        console.error(`Error: DOM element with ID '${getOriginalId(key)}' not found.`);
                    }
                }
            }
            if (!domElements.progressBar && domElements.progressBarContainer) {
                console.error(`Error: DOM element with ID 'progress-bar' not found, but 'progress-bar-container' exists.`);
            }
        }
        function getOriginalId(key) {
            const map = {
                quizContainer: 'quiz-container', modeSelectionContainer: 'mode-selection-container',
                yearListContainer: 'year-list-container', questionListContainer: 'question-list-container',
                questionContainer: 'question-container', questionCountSpan: 'question-count',
                questionTitle: 'question-title',
                questionTextDiv: 'question-text', optionsContainer: 'options-container',
                resultDiv: 'result', nextButton: 'next-button',
                backToPreviousScreenButton: 'back-to-previous-screen-button', quizEndMessage: 'quiz-end-message',
                finalScore: 'final-score', resetButton: 'reset-button',
                incorrectListContainer: 'incorrect-list-container', progressBar: 'progress-bar',
                progressBarContainer: 'progress-bar-container', randomModeButton: 'random-mode-button',
                backToModeSelectButton: 'back-to-mode-select-button',
                selectedYearTitle: 'selected-year-title',
                questionsForYearContainer: 'questions-for-year-container', backToYearSelectButton: 'back-to-year-select-button'
            };
            return map[key] || key;
        }

        function loadQuizData() {
            return fetch('houki.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    allQuizData = data;
                    initializeQuiz();
                })
                .catch(error => {
                    console.error('データの読み込みに失敗しました:', error);
                    if (domElements.quizContainer) {
                        domElements.quizContainer.innerHTML = `<p class="text-red-500">問題データの読み込みに失敗しました。ファイルを確認してください。</p>`;
                    }
                });
        }

        function initializeQuiz() {
            if (domElements.randomModeButton) domElements.randomModeButton.addEventListener('click', startRandomQuiz);
            if (domElements.yearSelectModeButton) domElements.yearSelectModeButton.addEventListener('click', showYearSelection);
            if (domElements.nextButton) domElements.nextButton.addEventListener('click', handleNextButton);
            if (domElements.resetButton) domElements.resetButton.addEventListener('click', resetQuiz);
            if (domElements.backToPreviousScreenButton) domElements.backToPreviousScreenButton.addEventListener('click', returnToPreviousScreen);
            if (domElements.backToModeSelectButton) domElements.backToModeSelectButton.addEventListener('click', showModeSelection);
            if (domElements.backToYearSelectButton) domElements.backToYearSelectButton.addEventListener('click', showYearSelection);
            showScreen('select');
        }

        function showScreen(screenName) {
            quizState.currentMode = screenName;
            const screens = [
                domElements.modeSelectionContainer, domElements.yearListContainer,
                domElements.questionListContainer, domElements.questionContainer,
                domElements.quizEndMessage
            ];
            screens.forEach(screen => { if (screen) screen.style.display = 'none'; });

            let targetScreen;
            switch (screenName) {
                case 'select': targetScreen = domElements.modeSelectionContainer; break;
                case 'year_select': targetScreen = domElements.yearListContainer; break;
                case 'question_list': targetScreen = domElements.questionListContainer; break;
                case 'quiz': targetScreen = domElements.questionContainer; break;
                case 'end': targetScreen = domElements.quizEndMessage; break;
                default: console.error("Unknown screen name:", screenName); return;
            }
            if (targetScreen) targetScreen.style.display = 'block';

            const isRandomQuiz = quizState.currentMode === 'quiz' && quizState.previousScreen === 'random_setup';
            if (domElements.progressBarContainer) domElements.progressBarContainer.style.display = isRandomQuiz ? 'block' : 'none';
            if (domElements.questionCountSpan) domElements.questionCountSpan.style.display = isRandomQuiz ? 'block' : 'none';
            if (domElements.backToPreviousScreenButton) domElements.backToPreviousScreenButton.style.display = 'none';
            if (domElements.backToModeSelectButton) domElements.backToModeSelectButton.style.display = screenName === 'year_select' ? 'block' : 'none';
            if (domElements.backToYearSelectButton) domElements.backToYearSelectButton.style.display = screenName === 'question_list' ? 'block' : 'none';
        }

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function startRandomQuiz() {
            if (allQuizData.length === 0) {
                console.error('問題データが見つかりません。');
                if (domElements.resultDiv) {
                    domElements.resultDiv.textContent = `問題データがありません。`;
                    domElements.resultDiv.className = 'result incorrect';
                }
                showScreen('end');
                if (domElements.finalScore) domElements.finalScore.textContent = 'クイズを開始できませんでした。';
                if (domElements.resetButton) domElements.resetButton.style.display = 'block';
                return;
            }
            quizState.previousScreen = 'random_setup';
            quizState.questions = shuffleArray(allQuizData).slice(0, NUMBER_OF_QUESTIONS_TO_ASK_RANDOM);
            if (quizState.questions.length < NUMBER_OF_QUESTIONS_TO_ASK_RANDOM) {
                console.warn(`問題データが${NUMBER_OF_QUESTIONS_TO_ASK_RANDOM}問未満です。取得できた${quizState.questions.length}問で開始します。`);
            }
            quizState.questions.forEach(q => {
                delete q.userChoice;
                delete q.isCorrect;
            });
            quizState.correctAnswers = 0;
            quizState.currentQuestionIndex = -1;
            quizState.incorrectQuestions = [];
            quizState.answered = false;
            if (domElements.optionsContainer) domElements.optionsContainer.classList.remove('answered');
            loadNextRandomQuestion();
        }

        function showYearSelection() {
            if (!domElements.yearButtonsContainer) {
                console.error("Element 'year-buttons-container' not found.");
                return;
            }
            quizState.questions = [];
            quizState.incorrectQuestions = [];
            quizState.correctAnswers = 0;
            quizState.currentQuestionIndex = -1;
            domElements.yearButtonsContainer.innerHTML = '';
            const years = [...new Set(allQuizData.map(q => q.年度))].sort((a, b) => b.localeCompare(a, 'ja'));
            years.forEach(year => {
                const button = document.createElement('button');
                button.className = 'year-button';
                button.textContent = year;
                button.addEventListener('click', () => showQuestionList(year));
                domElements.yearButtonsContainer.appendChild(button);
            });
            quizState.previousScreen = 'select';
            showScreen('year_select');
        }

        function showQuestionList(year) {
            if (!domElements.questionsForYearContainer || !domElements.selectedYearTitle) {
                console.error("Elements for question list not found.");
                return;
            }
            quizState.currentYear = year;
            quizState.questions = allQuizData.filter(q => q.年度 === year);
            quizState.currentQuestionIndex = -1;
            domElements.questionsForYearContainer.innerHTML = '';
            domElements.selectedYearTitle.textContent = `${year} の問題一覧`;

            if (quizState.questions.length > 0) {
                quizState.questions.forEach((question, index) => {
                    const listItem = document.createElement('div');
                    listItem.className = 'question-list-item';
                    if (question.hasOwnProperty('isCorrect')) {
                        listItem.classList.add('answered');
                        listItem.classList.add(question.isCorrect ? 'correct' : 'incorrect');
                    }
                    let questionPreview = question.問題文 ? question.問題文.substring(0, 50) + (question.問題文.length > 50 ? '...' : '') : '';
                    if (question.問題項目 && !questionPreview) questionPreview = '物象の状態の量と法定計量単位の組み合わせ問題';
                    else if (!questionPreview) questionPreview = '問題文なし';
                    let statusIndicator = question.hasOwnProperty('isCorrect') ? (question.isCorrect ? '✅' : '❌') : '未解答';
                    listItem.innerHTML = `<div><strong>${question.年度} ${question.問題番号}</strong>: ${questionPreview}</div><div class="status-indicator">${statusIndicator}</div>`;
                    listItem.addEventListener('click', () => {
                        const clickedIndex = quizState.questions.findIndex(q => q.問題番号 === question.問題番号 && q.年度 === question.年度);
                        if (clickedIndex !== -1) {
                            quizState.currentQuestionIndex = clickedIndex;
                            startSpecificQuestionQuiz(question, 'question_list');
                        } else {
                            console.error("Clicked question not found in the current year's list.");
                        }
                    });
                    domElements.questionsForYearContainer.appendChild(listItem);
                });
            } else {
                domElements.questionsForYearContainer.innerHTML = '<p>この年度の問題は見つかりませんでした。</p>';
            }
            quizState.previousScreen = 'year_select';
            showScreen('question_list');
        }

        function startSpecificQuestionQuiz(question, originScreen) {
            console.log(`startSpecificQuestionQuiz called from ${originScreen} for question: ${question.年度} ${question.問題番号}`);
            quizState.currentQuestionObject = question;
            quizState.answered = question.hasOwnProperty('userChoice');
            quizState.previousScreen = originScreen;

            if (originScreen === 'end_review') {
                quizState.questions = [question]; // レビュー時はこの1問のみ
                quizState.currentQuestionIndex = 0;
            }
            // originScreen === 'question_list' の場合、quizState.questions は既に年度別リスト、currentQuestionIndex も設定済み

            if (domElements.optionsContainer) {
                domElements.optionsContainer.classList.toggle('answered', quizState.answered);
            }
            displayQuestion(question);
            showScreen('quiz');
            if (domElements.progressBarContainer) domElements.progressBarContainer.style.display = 'none';
            if (domElements.questionCountSpan) domElements.questionCountSpan.style.display = 'none';
        }

        // 問題を表示する共通関数 (修正箇所)
        function displayQuestion(question) {
            console.log(`displayQuestion called. currentMode: ${quizState.currentMode}, previousScreen: ${quizState.previousScreen}, answered: ${quizState.answered}`);
            if (!question || !domElements.questionTitle || !domElements.questionTextDiv || !domElements.optionsContainer || !domElements.resultDiv || !domElements.nextButton || !domElements.questionCountSpan || !domElements.backToPreviousScreenButton) {
                console.error("Required DOM elements for displaying question are missing.");
                return;
            }

            quizState.currentQuestionObject = question;
            // quizState.answered は startSpecificQuestionQuiz または loadNextRandomQuestion で設定される

            domElements.optionsContainer.innerHTML = '';
            // quizState.answered の状態に基づいて answered クラスをトグルするが、
            // end_review の場合は後段で強制的に answered スタイルを適用する可能性あり
            domElements.optionsContainer.classList.toggle('answered', quizState.answered || quizState.previousScreen === 'end_review');


            domElements.resultDiv.textContent = '';
            domElements.resultDiv.className = 'result';
            domElements.nextButton.style.display = 'none'; // デフォルト非表示
            domElements.backToPreviousScreenButton.style.display = 'none'; // デフォルト非表示

            if (quizState.currentMode === 'quiz' && quizState.previousScreen === 'random_setup') {
                domElements.questionCountSpan.textContent = `${quizState.currentQuestionIndex + 1} / ${quizState.questions.length}`;
                domElements.questionCountSpan.style.display = 'block';
            } else {
                domElements.questionCountSpan.style.display = 'none';
            }
            domElements.questionTitle.textContent = `${question.年度} ${question.問題番号}`;

            if (question.問題項目) {
                let itemsHtml = '<div class="question-items-container">';
                if (question.問題文_original) itemsHtml += `<p class="mb-2">${question.問題文_original.replace(/\n/g, '<br>')}</p>`;
                itemsHtml += '<div class="question-items-header"><span></span> <span class="header-quantity">物象の状態の量</span> <span class="header-unit">法定計量単位</span></div>';
                question.問題項目.forEach(item => {
                    itemsHtml += `<div class="question-item"><span class="item-label">${item.項目}</span> <span class="item-quantity">${item.物象の状態の量}</span> <span class="item-unit">${item.法定計量単位}</span></div>`;
                });
                itemsHtml += '</div>';
                domElements.questionTextDiv.innerHTML = itemsHtml;
            } else if (question.問題文) {
                domElements.questionTextDiv.innerHTML = question.問題文.replace(/\n/g, '<br>');
            } else {
                domElements.questionTextDiv.textContent = '問題文の形式が不明です。';
            }

            if (question.選択肢) {
                question.選択肢.forEach((optionText, index) => {
                    const label = document.createElement('label');
                    label.className = 'option-label';
                    const input = document.createElement('input');
                    input.type = 'radio';
                    input.name = 'answer';
                    input.value = (index + 1).toString();
                    const span = document.createElement('span');
                    span.className = 'option-text-span';
                    span.textContent = `${index + 1}. ${optionText}`;
                    label.appendChild(input);
                    label.appendChild(span);
                    domElements.optionsContainer.appendChild(label);

                    // 間違えた問題レビュー時('end_review')は常に操作不可
                    if (quizState.answered || quizState.previousScreen === 'end_review') {
                        input.disabled = true;
                        if (question.userChoice && input.value === question.userChoice) { // userChoice が存在する場合のみチェック
                            input.checked = true;
                        }
                    } else {
                        input.addEventListener('change', handleOptionSelect);
                    }
                });
            }

            // 解答済み、または間違えた問題レビューの場合のスタイル適用とボタン表示
            if (quizState.answered) {
                applyAnswerStylesAndResult(question.userChoice, question.正解, question);
                // 通常の解答済み時のボタン表示ロジック
                if (quizState.previousScreen === 'random_setup') {
                    domElements.nextButton.style.display = 'block';
                    domElements.nextButton.textContent = (quizState.currentQuestionIndex < quizState.questions.length - 1) ? '次の問題へ' : '結果を見る';
                } else if (quizState.previousScreen === 'question_list') {
                    domElements.backToPreviousScreenButton.style.display = 'inline-block';
                    domElements.backToPreviousScreenButton.textContent = '問題一覧に戻る';
                    if (quizState.currentQuestionIndex < quizState.questions.length - 1) {
                        domElements.nextButton.style.display = 'inline-block';
                        domElements.nextButton.textContent = '次の問題へ';
                    }
                }
                // 'end_review' の場合のボタンは、この if ブロックの外で別途処理
            } else if (quizState.previousScreen === 'end_review') {
                // quizState.answered が false だが、'end_review' の場合 (本来は answered=true のはず)
                console.warn("displayQuestion: quizState.answered is false during end_review. Applying answered styles for review.");
                // 解答済みスタイルを適用 (ユーザーの選択は不明なので正解のみ表示)
                domElements.optionsContainer.querySelectorAll('input[type="radio"]').forEach(radio => {
                    radio.disabled = true; // 念のため
                    const label = radio.parentElement;
                    if (label) {
                        label.style.cursor = 'default';
                        if (radio.value === question.正解) {
                            label.classList.add('correct-answer');
                            const span = label.querySelector('.option-text-span');
                            if (span && !span.textContent.includes('✅')) span.textContent = '✅ ' + span.textContent;
                        }
                    }
                });
                if (domElements.resultDiv) {
                    domElements.resultDiv.textContent = `正解は ${question.正解} です。`;
                    domElements.resultDiv.className = 'result correct'; // 正解のみ表示
                }
            }

            // 間違えた問題レビュー ('end_review') の場合は、必ず「クイズ終了に戻る」ボタンを表示
            if (quizState.previousScreen === 'end_review') {
                if (domElements.backToPreviousScreenButton) {
                    domElements.backToPreviousScreenButton.style.display = 'inline-block';
                    domElements.backToPreviousScreenButton.textContent = 'クイズ終了に戻る';
                    console.log("Back button for 'end_review' is now visible.");
                } else {
                     console.error("backToPreviousScreenButton element not found when trying to show for end_review.");
                }
            }
        }


        function loadNextRandomQuestion() {
            console.log("loadNextRandomQuestion called.");
            if (!domElements.questionContainer || !domElements.quizEndMessage || !domElements.resultDiv || !domElements.nextButton || !domElements.incorrectListContainer || !domElements.resetButton || !domElements.questionTitle || !domElements.questionTextDiv || !domElements.optionsContainer || !domElements.progressBar || !domElements.progressBarContainer || !domElements.questionCountSpan || !domElements.backToPreviousScreenButton) {
                console.error("Required DOM elements for loadNextRandomQuestion are missing.");
                return;
            }
            quizState.answered = false; // 新しい問題なので未解答状態に
            if(domElements.optionsContainer) domElements.optionsContainer.classList.remove('answered');
            quizState.currentQuestionIndex++;
            if (domElements.resultDiv) {
                domElements.resultDiv.textContent = '';
                domElements.resultDiv.className = 'result';
            }
            if (domElements.nextButton) {
                domElements.nextButton.style.display = 'none';
                domElements.nextButton.textContent = '次の問題へ';
            }
            if (domElements.backToPreviousScreenButton) domElements.backToPreviousScreenButton.style.display = 'none';
            if (domElements.resetButton) domElements.resetButton.style.display = 'none';
            if (domElements.progressBarContainer) domElements.progressBarContainer.style.display = 'block';
            if (domElements.progressBar && quizState.questions.length > 0) {
                const progress = ((quizState.currentQuestionIndex) / quizState.questions.length) * 100;
                domElements.progressBar.style.width = `${progress}%`;
            }
            if (domElements.questionCountSpan && quizState.questions.length > 0) {
                domElements.questionCountSpan.textContent = `${quizState.currentQuestionIndex + 1} / ${quizState.questions.length}`;
                domElements.questionCountSpan.style.display = 'block';
            } else if (domElements.questionCountSpan) {
                domElements.questionCountSpan.style.display = 'none';
            }

            if (quizState.currentQuestionIndex < quizState.questions.length) {
                const currentQuestion = quizState.questions[quizState.currentQuestionIndex];
                quizState.currentQuestionObject = currentQuestion;
                // userChoice, isCorrect は startRandomQuiz でクリア済み、または handleOptionSelect で設定される
                displayQuestion(currentQuestion);
                showScreen('quiz');
            } else {
                if (domElements.progressBar) domElements.progressBar.style.width = `100%`;
                showScreen('end');
                if (domElements.finalScore) domElements.finalScore.textContent = `正答数: ${quizState.correctAnswers} / ${quizState.questions.length}`;
                if (domElements.resetButton) domElements.resetButton.style.display = 'block';
                displayIncorrectQuestions();
            }
        }

        function loadNextYearQuestion() {
            console.log("loadNextYearQuestion called.");
            if (!domElements.questionContainer || !domElements.resultDiv || !domElements.nextButton || !domElements.backToPreviousScreenButton || !domElements.questionTitle || !domElements.questionTextDiv || !domElements.optionsContainer) {
                console.error("Required DOM elements for loadNextYearQuestion are missing.");
                return;
            }
            // 年度別問題では、問題ごとに answered 状態をリセットせず、問題オブジェクトの解答履歴に依存する
            // quizState.answered は displayQuestion 内で currentQuestionObject から再設定される
            const nextQuestionIndex = quizState.currentQuestionIndex + 1;
            if (nextQuestionIndex < quizState.questions.length) {
                 quizState.currentQuestionIndex = nextQuestionIndex;
                 const currentQuestion = quizState.questions[quizState.currentQuestionIndex];
                 quizState.currentQuestionObject = currentQuestion;
                 quizState.answered = currentQuestion.hasOwnProperty('userChoice'); // 次の問題の解答状態をセット

                 if(domElements.optionsContainer) domElements.optionsContainer.classList.toggle('answered', quizState.answered);

                 if (domElements.resultDiv) {
                     domElements.resultDiv.textContent = '';
                     domElements.resultDiv.className = 'result';
                 }
                 if (domElements.nextButton) domElements.nextButton.style.display = 'none';
                 if (domElements.backToPreviousScreenButton) domElements.backToPreviousScreenButton.style.display = 'none';

                 displayQuestion(currentQuestion);
                 showScreen('quiz');
            } else {
                console.warn("Attempted to load next year question beyond the list length.");
                // 年度内の最後の問題だった場合は問題一覧に戻る
                if (quizState.currentYear) {
                    showQuestionList(quizState.currentYear);
                } else {
                    showYearSelection();
                }
            }
        }

        function handleOptionSelect(event) {
            console.log(`handleOptionSelect called. previousScreen: ${quizState.previousScreen}`);
            if (quizState.answered) return;
            const currentQuestion = quizState.currentQuestionObject;
            if (!currentQuestion || !domElements.optionsContainer || !domElements.resultDiv || !domElements.nextButton || !domElements.backToPreviousScreenButton) {
                console.error("Cannot handle option select: current question or DOM elements missing.");
                return;
            }
            quizState.answered = true;
            domElements.optionsContainer.classList.add('answered');
            const selectedAnswerInput = event.target;
            const selectedValue = selectedAnswerInput.value;
            const correctAnswer = currentQuestion.正解;
            currentQuestion.userChoice = selectedValue;
            currentQuestion.isCorrect = (selectedValue === correctAnswer);
            applyAnswerStylesAndResult(selectedValue, correctAnswer, currentQuestion);

            if (quizState.previousScreen === 'random_setup') {
                if (domElements.nextButton) {
                    domElements.nextButton.style.display = 'block';
                    domElements.nextButton.textContent = (quizState.currentQuestionIndex < quizState.questions.length - 1) ? '次の問題へ' : '結果を見る';
                }
            } else if (quizState.previousScreen === 'question_list') {
                if (domElements.backToPreviousScreenButton) {
                    domElements.backToPreviousScreenButton.style.display = 'inline-block';
                    domElements.backToPreviousScreenButton.textContent = '問題一覧に戻る';
                }
                if (quizState.currentQuestionIndex < quizState.questions.length - 1) {
                    if (domElements.nextButton) {
                        domElements.nextButton.style.display = 'inline-block';
                        domElements.nextButton.textContent = '次の問題へ';
                    }
                }
            }
            // 'end_review' の場合は、選択肢が無効なのでこの関数は呼ばれない想定。
            // もし呼ばれたとしても、displayQuestion側でボタン表示は制御される。
        }

        function applyAnswerStylesAndResult(selectedValue, correctAnswer, questionObject) {
            console.log(`applyAnswerStylesAndResult called. previousScreen: ${quizState.previousScreen}`);
            if (!domElements.optionsContainer || !domElements.resultDiv) return;
            domElements.optionsContainer.querySelectorAll('input[type="radio"]').forEach(radio => {
                radio.disabled = true;
                const label = radio.parentElement;
                if (label) {
                    label.style.cursor = 'default';
                    const optionValue = radio.value;
                    if (optionValue === correctAnswer) label.classList.add('correct-answer');
                    if (optionValue === selectedValue && selectedValue !== correctAnswer) label.classList.add('incorrect-answer');
                    if (optionValue === correctAnswer) {
                        const span = label.querySelector('.option-text-span');
                        if (span && !span.textContent.includes('✅')) span.textContent = '✅ ' + span.textContent;
                    }
                }
            });
            if (questionObject.isCorrect) {
                domElements.resultDiv.textContent = '正解です！';
                domElements.resultDiv.className = 'result correct';
                if (quizState.previousScreen === 'random_setup') quizState.correctAnswers++;
            } else {
                domElements.resultDiv.textContent = `不正解です。正解は ${correctAnswer} です。`;
                domElements.resultDiv.className = 'result incorrect';
                if (quizState.previousScreen === 'random_setup' && !quizState.incorrectQuestions.find(q => q.問題番号 === questionObject.問題番号 && q.年度 === questionObject.年度)) {
                    quizState.incorrectQuestions.push(questionObject);
                }
            }
        }

        function handleNextButton() {
            console.log(`handleNextButton called. previousScreen: ${quizState.previousScreen}`);
            if (quizState.previousScreen === 'random_setup') {
                if (quizState.currentQuestionIndex < quizState.questions.length - 1) {
                    loadNextRandomQuestion();
                } else {
                    if (domElements.progressBar) domElements.progressBar.style.width = `100%`;
                    showScreen('end');
                    if (domElements.finalScore) domElements.finalScore.textContent = `正答数: ${quizState.correctAnswers} / ${quizState.questions.length}`;
                    if (domElements.resetButton) domElements.resetButton.style.display = 'block';
                    displayIncorrectQuestions();
                }
            } else if (quizState.previousScreen === 'question_list') {
                if (quizState.currentQuestionIndex < quizState.questions.length - 1) {
                    loadNextYearQuestion();
                } else {
                    if (quizState.currentYear) showQuestionList(quizState.currentYear);
                    else showYearSelection();
                }
            }
        }

        function displayIncorrectQuestions() {
            console.log("displayIncorrectQuestions called.");
            if (!domElements.incorrectListContainer || !domElements.quizEndMessage || !domElements.resetButton) return;
            domElements.incorrectListContainer.innerHTML = '';
            if (quizState.incorrectQuestions.length > 0) {
                const title = document.createElement('h3');
                title.className = 'text-xl text-red-700 mb-4';
                title.textContent = '間違えた問題';
                domElements.incorrectListContainer.appendChild(title);
                const ul = document.createElement('ul');
                ul.id = 'incorrect-list';
                quizState.incorrectQuestions.forEach((question) => {
                    const li = document.createElement('li');
                    let questionPreview = question.問題文 ? question.問題文.substring(0,30)+'...' : (question.問題項目 ? '表形式問題' : '問題文なし');
                    if (question.問題文 && question.問題文.length <= 30) questionPreview = question.問題文;
                    li.innerHTML = `<strong>${question.年度} ${question.問題番号}</strong>: ${questionPreview}`;
                    li.addEventListener('click', () => {
                        console.log("Clicked incorrect question from list:", JSON.stringify(question));
                        console.log("Does it have userChoice?", question.hasOwnProperty('userChoice'));
                        startSpecificQuestionQuiz(question, 'end_review');
                    });
                    ul.appendChild(li);
                });
                domElements.incorrectListContainer.appendChild(ul);
            } else {
                domElements.incorrectListContainer.innerHTML = '<p class="text-lg text-green-700">素晴らしい！全問正解です！</p>';
            }
        }

        function returnToPreviousScreen() {
            console.log(`returnToPreviousScreen called. previousScreen: ${quizState.previousScreen}`);
            const targetScreen = quizState.previousScreen; // 戻るべき画面を保持

            // 状態をリセットしてから画面遷移
            if (domElements.nextButton) domElements.nextButton.style.display = 'none';
            if (domElements.backToPreviousScreenButton) domElements.backToPreviousScreenButton.style.display = 'none';
            if (domElements.progressBarContainer) domElements.progressBarContainer.style.display = 'none';
            if (domElements.progressBar) domElements.progressBar.style.width = '0%';
            if (domElements.questionCountSpan) domElements.questionCountSpan.style.display = 'none';
            if (domElements.optionsContainer) domElements.optionsContainer.classList.remove('answered');
            if (domElements.resultDiv) {
                domElements.resultDiv.textContent = '';
                domElements.resultDiv.className = 'result';
            }

            if (targetScreen === 'question_list' && quizState.currentYear) {
                showQuestionList(quizState.currentYear);
            } else if (targetScreen === 'end_review') {
                showScreen('end');
                // ランダムモードの結果表示を復元
                if (domElements.finalScore) domElements.finalScore.textContent = `正答数: ${quizState.correctAnswers} / ${NUMBER_OF_QUESTIONS_TO_ASK_RANDOM}`;
                if (domElements.resetButton) domElements.resetButton.style.display = 'block';
                displayIncorrectQuestions();
            } else if (targetScreen === 'year_select') {
                showYearSelection();
            } else {
                showModeSelection(); // デフォルト
            }
        }

        function showModeSelection() {
            console.log("showModeSelection called.");
            quizState = {
                currentMode: 'select', questions: [], currentQuestionIndex: -1,
                currentQuestionObject: null, correctAnswers: 0, incorrectQuestions: [],
                answered: false, currentYear: null, previousScreen: 'select'
            };
            allQuizData.forEach(q => { delete q.userChoice; delete q.isCorrect; });
            showScreen('select');
            if (domElements.yearButtonsContainer) domElements.yearButtonsContainer.innerHTML = '';
            if (domElements.questionsForYearContainer) domElements.questionsForYearContainer.innerHTML = '';
            if (domElements.incorrectListContainer) domElements.incorrectListContainer.innerHTML = '';
            if (domElements.resultDiv) domElements.resultDiv.textContent = '';
            if (domElements.finalScore) domElements.finalScore.textContent = '';
            if (domElements.questionTitle) domElements.questionTitle.textContent = '';
            if (domElements.questionTextDiv) domElements.questionTextDiv.innerHTML = '';
            if (domElements.optionsContainer) domElements.optionsContainer.innerHTML = '';
            if (domElements.nextButton) domElements.nextButton.style.display = 'none';
            if (domElements.backToPreviousScreenButton) domElements.backToPreviousScreenButton.style.display = 'none';
            if (domElements.resetButton) domElements.resetButton.style.display = 'none';
            if (domElements.progressBarContainer) domElements.progressBarContainer.style.display = 'none';
            if (domElements.progressBar) domElements.progressBar.style.width = '0%';
            if (domElements.questionCountSpan) domElements.questionCountSpan.style.display = 'none';
        }

        function resetQuiz() {
            console.log("resetQuiz called.");
            showModeSelection();
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded.");
            cacheDOMElements();
            loadQuizData();
        });
    </script>

</body>
</html>
