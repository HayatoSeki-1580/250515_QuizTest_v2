<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>社内学習ブラウザ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Ensure Inter font is loaded, Tailwind uses it by default */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom styles */
        /* Style for options */
        .option-label {
            display: block;
            margin-bottom: 0.75rem; /* 12px */
            padding: 0.75rem; /* 12px */
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.375rem; /* 6px */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: #ffffff; /* white */
        }

        /* Allow pointer cursor only when not answered */
        #options-container:not(.answered) .option-label {
            cursor: pointer;
        }

        #options-container:not(.answered) .option-label:hover {
            background-color: #f3f4f6; /* gray-100 */
            border-color: #9ca3af; /* gray-400 */
        }

        /* Style for selected option (before checking) */
        #options-container:not(.answered) .option-label input[type="radio"]:checked + .option-text-span {
            font-weight: 500; /* medium */
            color: #1e40af; /* blue-800 */
        }

        /* Style for selected option (before checking) - parent label style */
        #options-container:not(.answered) .option-label input[type="radio"]:checked + .option-text-span::before {
            content: '▶ ';
            color: #2563eb; /* blue-600 */
        }

        /* Style for correct answer */
        .option-label.correct-answer {
            background-color: #d1fae5; /* green-100 */
            border-color: #34d399; /* green-400 */
            font-weight: bold;
        }

        /* Style for incorrect answer selected by user */
        .option-label.incorrect-answer {
            background-color: #fee2e2; /* red-100 */
            border-color: #f87171; /* red-400 */
        }

        /* Style for non-selected options after answer */
        #options-container.answered .option-label:not(.correct-answer):not(.incorrect-answer) {
            opacity: 0.6;
        }

        /* Hide default radio button */
        .option-label input[type="radio"] {
            display: none;
        }

        /* Style for result message */
        .result {
            margin-top: 1.25rem; /* 20px */
            padding: 0.75rem; /* 12px */
            border-radius: 0.375rem; /* 6px */
            font-weight: bold;
            min-height: 1.5em; /* Ensure space even if empty */
        }

        .result.correct {
            background-color: #d1fae5; /* green-100 */
            color: #065f46; /* green-800 */
            border: 1px solid #a7f3d0; /* green-200 */
        }

        .result.incorrect {
            background-color: #fee2e2; /* red-100 */
            color: #991b1b; /* red-800 */
            border: 1px solid #fecaca; /* red-200 */
        }

        /* Style for incorrect list items */
        #incorrect-list li {
            background-color: #fef2f2; /* red-50 */
            border: 1px solid #fecaca; /* red-200 */
            border-radius: 0.25rem; /* 4px */
            padding: 0.75rem; /* 12px */
            margin-bottom: 0.5rem; /* 8px */
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #incorrect-list li:hover {
            background-color: #fee2e2; /* red-100 */
        }
        #incorrect-list li strong {
            color: #b91c1c; /* red-700 */
        }

        /* Progress bar styles */
        #progress-bar-container {
            width: 100%;
            background-color: #e5e7eb; /* gray-200 */
            border-radius: 9999px; /* full */
            height: 8px; /* h-2 */
            margin-bottom: 1.5rem; /* 24px */
            overflow: hidden; /* Ensure inner bar respects rounded corners */
        }

        #progress-bar {
            height: 100%;
            width: 0%; /* Initial width */
            background-color: #3b82f6; /* blue-500 */
            border-radius: 9999px; /* full */
            transition: width 0.5s ease-in-out;
        }

        /* Styles for formatted question items */
        .question-items-container {
            margin-top: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.375rem; /* rounded-md */
            overflow: hidden; /* For rounded corners on children */
        }

        .question-item, .question-items-header {
            display: grid;
            grid-template-columns: 2rem 2rem 12rem 1fr; /* Adjust as needed */
            gap: 0.5rem; /* gap-2 */
            padding: 0.75rem; /* p-3 */
            border-bottom: 1px solid #e5e7eb; /* gray-200 */
            align-items: center; /* vertical alignment */
        }

        .question-item:last-child {
            border-bottom: none; /* Remove border for the last item */
        }

        .question-item .item-label {
            font-weight: bold;
            grid-column: 2 / 3; /* Place in the second column */
        }

        .question-item .item-quantity {
            grid-column: 3 / 4; /* Place in the third column */
        }

        .question-item .item-unit {
            grid-column: 4 / 5; /* Place in the fourth column */
        }

        .question-items-header {
            font-weight: bold;
            background-color: #f9fafb; /* gray-50 */
            border-bottom: 1px solid #d1d5db; /* gray-300 */
            grid-template-columns: 2rem 2rem 12rem 1fr; /* Must match .question-item */
        }

        .question-items-header .header-quantity {
            grid-column: 3 / 4; /* Align with item-quantity */
        }

        .question-items-header .header-unit {
            grid-column: 4 / 5; /* Align with item-unit */
        }

        @media (max-width: 600px) {
            .question-item, .question-items-header {
                grid-template-columns: 1.5rem 1.5rem 8rem 1fr; /* Narrower columns */
                gap: 0.3rem;
                padding: 0.5rem;
            }
            .question-item .item-quantity {
                grid-column: 3 / 4;
            }
            .question-item .item-unit {
                grid-column: 4 / 5;
            }
            .question-items-header .header-quantity {
                grid-column: 3 / 4;
            }
            .question-items-header .header-unit {
                grid-column: 4 / 5;
            }
        }

        /* Styles for mode selection and year list */
        #mode-selection-container, #year-list-container, #question-list-container {
            display: none; /* Initially hidden, controlled by JS */
            text-align: center;
        }

        .mode-button, .year-button, .question-list-item {
            display: block;
            width: 100%;
            padding: 1rem;
            margin-bottom: 1rem;
            font-size: 1.25rem;
            font-weight: 600;
            color: #ffffff;
            background-color: #3b82f6; /* blue-500 */
            border-radius: 0.375rem; /* rounded-md */
            cursor: pointer;
            transition: background-color 0.3s ease;
            text-align: center;
        }

        .mode-button:hover, .year-button:hover, .question-list-item:hover {
            background-color: #2563eb; /* blue-600 */
        }

        .year-button {
            background-color: #10b981; /* green-500 */
        }

        .year-button:hover {
            background-color: #059669; /* green-600 */
        }

        .question-list-item {
            background-color: #60a5fa; /* blue-400 */
            font-size: 1rem;
            text-align: left;
            display: flex; /* Use flexbox for better alignment */
            align-items: center;
            justify-content: space-between; /* Space out content and status */
        }

        .question-list-item:hover {
            background-color: #3b82f6; /* blue-500 */
        }

        .question-list-item .status-indicator {
            font-weight: bold;
            margin-left: 1rem; /* Space from text */
        }

        .question-list-item.answered .status-indicator {
            color: #4b5563; /* gray-600 */
        }

        .question-list-item.correct .status-indicator {
            color: #059669; /* green-600 */
        }

        .question-list-item.incorrect .status-indicator {
            color: #dc2626; /* red-600 */
        }

        #question-list-container h3 {
            font-size: 1.5rem;
            color: #1e40af; /* blue-800 */
            margin-bottom: 1.5rem;
        }

        .back-button {
            margin-top: 1.5rem;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            color: #ffffff;
            background-color: #6b7280; /* gray-500 */
            border-radius: 0.375rem; /* rounded-md */
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .back-button:hover {
            background-color: #4b5563; /* gray-600 */
        }

        #question-count {
            font-size: 1rem;
            font-weight: bold;
            color: #4b5563; /* gray-600 */
            margin-bottom: 0.5rem; /* space between count and title */
            display: block; /* Ensure it takes its own line */
        }
    </style>
</head>
<body class="bg-gray-100 flex justify-center items-start min-h-screen py-8 px-4">

    <div id="quiz-container" class="bg-white p-8 rounded-lg shadow-xl max-w-xl w-full">

        <div id="mode-selection-container">
            <h2 class="text-2xl text-blue-700 mb-6">学習モード選択</h2>
            <button id="random-mode-button" class="mode-button">ランダム出題開始 (5問)</button>
            <button id="year-select-mode-button" class="mode-button">年度を選択して学習</button>
        </div>

        <div id="year-list-container">
            <h2 class="text-2xl text-blue-700 mb-6">年度選択</h2>
            <div id="year-buttons-container">
            </div>
            <button id="back-to-mode-select-button" class="back-button">モード選択に戻る</button>
        </div>

        <div id="question-list-container">
            <h3 id="selected-year-title"></h3>
            <div id="questions-for-year-container">
            </div>
            <button id="back-to-year-select-button" class="back-button">年度選択に戻る</button>
        </div>

        <div id="question-container">
            <div id="progress-bar-container">
                <div id="progress-bar"></div>
            </div>
            <span id="question-count" style="display: none;"></span>
            <h2 id="question-title" class="text-xl md:text-2xl text-blue-700 mb-4 pb-2 border-b-2 border-blue-700"></h2>
            <div id="question-text" class="mb-6 whitespace-pre-wrap text-gray-800"></div>
            <div id="options-container">
            </div>
            <div id="result" class="result"></div>
            <div class="mt-6 flex flex-col md:flex-row justify-center gap-4">
                <button id="next-button" class="px-6 py-3 text-lg font-semibold text-white bg-green-600 hover:bg-green-700 rounded-md cursor-pointer transition-colors duration-300 w-full md:w-auto" style="display: none;">次の問題へ</button>
                <button id="back-to-previous-screen-button" class="px-6 py-3 text-lg font-semibold text-white bg-gray-600 hover:bg-gray-700 rounded-md cursor-pointer transition-colors duration-300 w-full md:w-auto" style="display: none;">戻る</button>
            </div>
        </div>

        <div id="quiz-end-message" class="mt-8 text-center" style="display: none;">
            <h2 class="text-2xl text-blue-700 mb-4">クイズ終了！</h2>
            <p id="final-score" class="text-xl mb-5 font-semibold"></p>
            <div id="incorrect-list-container" class="mt-8 text-left border-t pt-5">
            </div>
            <button id="reset-button" class="mt-6 px-6 py-3 text-lg font-semibold text-gray-800 bg-yellow-400 hover:bg-yellow-500 rounded-md cursor-pointer transition-colors duration-300 w-full md:w-auto">もう一度挑戦する</button>
        </div>
    </div>

    <script>
        // グローバルスコープに配置するデータと定数
        let allQuizData = []; // JSONから読み込む全クイズデータ
        const NUMBER_OF_QUESTIONS_TO_ASK_RANDOM = 5; // ランダム出題時の問題数

        // クイズの状態を管理するオブジェクト
        let quizState = {
            currentMode: 'select', // 'select', 'random_setup', 'year_select', 'question_list', 'quiz', 'end', 'review_incorrect'
            questions: [], // 現在のクイズセッションで使われる問題の配列
            currentQuestionIndex: -1,
            currentQuestionObject: null, // 現在表示中の問題オブジェクト
            correctAnswers: 0,
            incorrectQuestions: [], // ランダムモードで間違えた問題のリスト
            answered: false, // 現在の問題が解答済みか (主にランダムクイズと年度別クイズで使用)
            currentYear: null, // 年度選択モードで選択された年度
            previousScreen: 'select' // 「戻る」ボタンのための前の画面情報
        };

        // DOM要素の取得 (グローバルで一度だけ行う)
        const domElements = {};

        function cacheDOMElements() {
            domElements.quizContainer = document.getElementById('quiz-container');
            domElements.modeSelectionContainer = document.getElementById('mode-selection-container');
            domElements.yearListContainer = document.getElementById('year-list-container');
            domElements.questionListContainer = document.getElementById('question-list-container');
            domElements.questionContainer = document.getElementById('question-container');
            domElements.questionCountSpan = document.getElementById('question-count');
            domElements.questionTitle = document.getElementById('question-title');
            domElements.questionTextDiv = document.getElementById('question-text');
            domElements.optionsContainer = document.getElementById('options-container');
            domElements.resultDiv = document.getElementById('result');
            domElements.nextButton = document.getElementById('next-button');
            domElements.backToPreviousScreenButton = document.getElementById('back-to-previous-screen-button');
            domElements.quizEndMessage = document.getElementById('quiz-end-message');
            domElements.finalScore = document.getElementById('final-score');
            domElements.resetButton = document.getElementById('reset-button');
            domElements.incorrectListContainer = document.getElementById('incorrect-list-container');
            domElements.progressBar = document.getElementById('progress-bar');
            domElements.progressBarContainer = document.getElementById('progress-bar-container');
            domElements.randomModeButton = document.getElementById('random-mode-button');
            domElements.yearSelectModeButton = document.getElementById('year-select-mode-button');
            domElements.yearButtonsContainer = document.getElementById('year-buttons-container');
            domElements.backToModeSelectButton = document.getElementById('back-to-mode-select-button');
            domElements.selectedYearTitle = document.getElementById('selected-year-title');
            domElements.questionsForYearContainer = document.getElementById('questions-for-year-container');
            domElements.backToYearSelectButton = document.getElementById('back-to-year-select-button');

            for (const key in domElements) {
                if (!domElements[key] && key !== 'progressBar') {
                    if(key === 'progressBarContainer' && !domElements.progressBar) { /* progressBarContainer implies progressBar */ }
                    else if (key === 'progressBar' && !domElements.progressBarContainer) { /* progressBar implies progressBarContainer */ }
                    else {
                        console.error(`Error: DOM element with ID '${getOriginalId(key)}' not found.`);
                    }
                }
            }
            if (!domElements.progressBar && domElements.progressBarContainer) {
                console.error(`Error: DOM element with ID 'progress-bar' not found, but 'progress-bar-container' exists.`);
            }
        }
        function getOriginalId(key) {
            const map = {
                quizContainer: 'quiz-container', modeSelectionContainer: 'mode-selection-container',
                yearListContainer: 'year-list-container', questionListContainer: 'question-list-container',
                questionContainer: 'question-container', questionCountSpan: 'question-count',
                questionTitle: 'question-title',
                questionTextDiv: 'question-text', optionsContainer: 'options-container',
                resultDiv: 'result', nextButton: 'next-button',
                backToPreviousScreenButton: 'back-to-previous-screen-button', quizEndMessage: 'quiz-end-message',
                finalScore: 'final-score', resetButton: 'reset-button',
                incorrectListContainer: 'incorrect-list-container', progressBar: 'progress-bar',
                progressBarContainer: 'progress-bar-container', randomModeButton: 'random-mode-button',
                backToModeSelectButton: 'back-to-mode-select-button',
                selectedYearTitle: 'selected-year-title',
                questionsForYearContainer: 'questions-for-year-container', backToYearSelectButton: 'back-to-year-select-button'
            };
            return map[key] || key;
        }

        function loadQuizData() {
            return fetch('houki.json') // ローカルのJSONファイル名を指定
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    allQuizData = data;
                    initializeQuiz();
                })
                .catch(error => {
                    console.error('データの読み込みに失敗しました:', error);
                    if (domElements.quizContainer) {
                        domElements.quizContainer.innerHTML = `<p class="text-red-500">問題データの読み込みに失敗しました。ファイルを確認してください。</p>`;
                    }
                });
        }

        function initializeQuiz() {
            if (domElements.randomModeButton) domElements.randomModeButton.addEventListener('click', startRandomQuiz);
            if (domElements.yearSelectModeButton) domElements.yearSelectModeButton.addEventListener('click', showYearSelection);
            if (domElements.nextButton) domElements.nextButton.addEventListener('click', handleNextButton);
            if (domElements.resetButton) domElements.resetButton.addEventListener('click', resetQuiz);
            if (domElements.backToPreviousScreenButton) domElements.backToPreviousScreenButton.addEventListener('click', returnToPreviousScreen);
            if (domElements.backToModeSelectButton) domElements.backToModeSelectButton.addEventListener('click', showModeSelection);
            if (domElements.backToYearSelectButton) domElements.backToYearSelectButton.addEventListener('click', showYearSelection);
            showScreen('select');
        }

        function showScreen(screenName, callingFunction = "") {
            console.log(`showScreen called for: ${screenName}, from: ${callingFunction}, previousScreen was: ${quizState.previousScreen}, currentMode will be: ${screenName}`);
            // quizState.previousScreen は、画面遷移をトリガーするアクション (例: startRandomQuiz) の中で設定する
            quizState.currentMode = screenName;

            const screens = [
                domElements.modeSelectionContainer, domElements.yearListContainer,
                domElements.questionListContainer, domElements.questionContainer,
                domElements.quizEndMessage
            ];
            screens.forEach(screen => { if (screen) screen.style.display = 'none'; });

            let targetScreen;
            switch (screenName) {
                case 'select': targetScreen = domElements.modeSelectionContainer; break;
                case 'year_select': targetScreen = domElements.yearListContainer; break;
                case 'question_list': targetScreen = domElements.questionListContainer; break;
                case 'quiz': targetScreen = domElements.questionContainer; break; // 'quiz' はランダム、年度別、レビュー共通
                case 'end': targetScreen = domElements.quizEndMessage; break;
                default: console.error("Unknown screen name:", screenName); return;
            }
            if (targetScreen) targetScreen.style.display = 'block';

            // プログレスバーと問題数表示の制御
            const isRandomQuizActive = quizState.previousScreen === 'random_setup' && screenName === 'quiz';
            if (domElements.progressBarContainer) domElements.progressBarContainer.style.display = isRandomQuizActive ? 'block' : 'none';
            if (domElements.questionCountSpan) domElements.questionCountSpan.style.display = isRandomQuizActive ? 'block' : 'none';

            // 各画面固有の戻るボタンの表示制御
            if (domElements.backToModeSelectButton) domElements.backToModeSelectButton.style.display = screenName === 'year_select' ? 'block' : 'none';
            if (domElements.backToYearSelectButton) domElements.backToYearSelectButton.style.display = screenName === 'question_list' ? 'block' : 'none';
            // 問題画面の「戻る」ボタンは displayQuestion で制御
        }

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function startRandomQuiz() {
            console.log("startRandomQuiz called");
            if (allQuizData.length === 0) {
                // ... (エラー処理は省略)
                return;
            }
            quizState.previousScreen = 'random_setup'; // ★重要: 次の画面の「戻る」先を示す
            quizState.questions = shuffleArray(allQuizData).slice(0, NUMBER_OF_QUESTIONS_TO_ASK_RANDOM);
            quizState.questions.forEach(q => { delete q.userChoice; delete q.isCorrect; });
            quizState.correctAnswers = 0;
            quizState.currentQuestionIndex = -1;
            quizState.incorrectQuestions = [];
            quizState.answered = false; // 新しいクイズセッションなので未解答
            if (domElements.optionsContainer) domElements.optionsContainer.classList.remove('answered');
            loadNextQuestion(); // 最初の問題へ
        }

        function showYearSelection() {
            console.log("showYearSelection called");
            quizState.previousScreen = 'select'; // ★重要
            // ... (年度ボタン生成処理は省略、変更なし)
            quizState.questions = [];
            quizState.incorrectQuestions = [];
            quizState.correctAnswers = 0;
            quizState.currentQuestionIndex = -1;
            domElements.yearButtonsContainer.innerHTML = '';
            const years = [...new Set(allQuizData.map(q => q.年度))].sort((a, b) => b.localeCompare(a, 'ja'));
            years.forEach(year => {
                const button = document.createElement('button');
                button.className = 'year-button';
                button.textContent = year;
                button.addEventListener('click', () => showQuestionList(year));
                domElements.yearButtonsContainer.appendChild(button);
            });
            showScreen('year_select', 'showYearSelection');
        }

        function showQuestionList(year) {
            console.log(`showQuestionList called for year: ${year}`);
            quizState.previousScreen = 'year_select'; // ★重要
            quizState.currentYear = year;
            quizState.questions = allQuizData.filter(q => q.年度 === year); // この年度の問題をセット
            quizState.currentQuestionIndex = -1; // リスト表示なのでインデックスはリセット
            // ... (問題リスト表示DOM操作は省略、変更なし)
            domElements.questionsForYearContainer.innerHTML = '';
            domElements.selectedYearTitle.textContent = `${year} の問題一覧`;

            if (quizState.questions.length > 0) {
                quizState.questions.forEach((question) => { // index は不要
                    const listItem = document.createElement('div');
                    listItem.className = 'question-list-item';
                    if (question.hasOwnProperty('isCorrect')) {
                        listItem.classList.add('answered');
                        listItem.classList.add(question.isCorrect ? 'correct' : 'incorrect');
                    }
                    let questionPreview = question.問題文 ? question.問題文.substring(0, 50) + (question.問題文.length > 50 ? '...' : '') : '';
                    if (question.問題項目 && !questionPreview) questionPreview = '物象の状態の量と法定計量単位の組み合わせ問題';
                    else if (!questionPreview) questionPreview = '問題文なし';
                    let statusIndicator = question.hasOwnProperty('isCorrect') ? (question.isCorrect ? '✅' : '❌') : '未解答';
                    listItem.innerHTML = `<div><strong>${question.年度} ${question.問題番号}</strong>: ${questionPreview}</div><div class="status-indicator">${statusIndicator}</div>`;
                    listItem.addEventListener('click', () => {
                        // クリックされた問題のインデックスを quizState.questions (現在の年度の問題リスト) から探す
                        const clickedIndexInYearList = quizState.questions.findIndex(q => q.問題番号 === question.問題番号 && q.年度 === question.年度);
                        if (clickedIndexInYearList !== -1) {
                            quizState.currentQuestionIndex = clickedIndexInYearList; // 年度リスト内のインデックスを設定
                            startSpecificQuestionQuiz(question, 'question_list');
                        } else {
                            console.error("Clicked question not found in the current year's list.");
                        }
                    });
                    domElements.questionsForYearContainer.appendChild(listItem);
                });
            } else {
                domElements.questionsForYearContainer.innerHTML = '<p>この年度の問題は見つかりませんでした。</p>';
            }
            showScreen('question_list', 'showQuestionList');
        }

        // 特定の問題を開始 (年度別リストから、または間違えた問題レビューから)
        function startSpecificQuestionQuiz(question, originScreen) {
            console.log(`startSpecificQuestionQuiz called for: ${question.年度} ${question.問題番号}, from: ${originScreen}`);
            quizState.currentQuestionObject = question;
            quizState.previousScreen = originScreen; // ★重要: 'question_list' または 'review_incorrect'

            if (originScreen === 'review_incorrect') {
                quizState.questions = [question]; // レビュー時はこの1問のみが現在の問題リスト
                quizState.currentQuestionIndex = 0;
                quizState.answered = true; // 間違えた問題は必ず解答済み
            } else if (originScreen === 'question_list') {
                // quizState.questions は既に showQuestionList で年度別問題リストが設定済み
                // quizState.currentQuestionIndex は showQuestionList のクリックリスナーで設定済み
                quizState.answered = question.hasOwnProperty('userChoice'); // 年度別問題は解答履歴に依存
            }

            if (domElements.optionsContainer) {
                domElements.optionsContainer.classList.toggle('answered', quizState.answered);
            }
            displayQuestion(question);
            showScreen('quiz', 'startSpecificQuestionQuiz');
        }


        function displayQuestion(question) {
            console.log(`displayQuestion: q=${question.年度}-${question.問題番号}, prevScreen=${quizState.previousScreen}, answered=${quizState.answered}`);
            if (!question || !domElements.questionTitle /* ...他の必須要素チェック... */) {
                console.error("displayQuestion: Required DOM elements missing."); return;
            }

            quizState.currentQuestionObject = question; // 常に最新の問題をセット

            domElements.optionsContainer.innerHTML = '';
            domElements.resultDiv.textContent = '';
            domElements.resultDiv.className = 'result';
            domElements.nextButton.style.display = 'none';
            domElements.backToPreviousScreenButton.style.display = 'none';

            // 問題番号・タイトル表示
            if (quizState.previousScreen === 'random_setup') { // ランダムクイズ中のみ問題数を表示
                domElements.questionCountSpan.textContent = `${quizState.currentQuestionIndex + 1} / ${quizState.questions.length}`;
                domElements.questionCountSpan.style.display = 'block';
            } else {
                domElements.questionCountSpan.style.display = 'none';
            }
            domElements.questionTitle.textContent = `${question.年度} ${question.問題番号}`;

            // 問題文表示 (変更なし)
            if (question.問題項目) {
                let itemsHtml = '<div class="question-items-container">';
                if (question.問題文_original) itemsHtml += `<p class="mb-2">${question.問題文_original.replace(/\n/g, '<br>')}</p>`;
                itemsHtml += '<div class="question-items-header"><span></span> <span class="header-quantity">物象の状態の量</span> <span class="header-unit">法定計量単位</span></div>';
                question.問題項目.forEach(item => {
                    itemsHtml += `<div class="question-item"><span class="item-label">${item.項目}</span> <span class="item-quantity">${item.物象の状態の量}</span> <span class="item-unit">${item.法定計量単位}</span></div>`;
                });
                itemsHtml += '</div>';
                domElements.questionTextDiv.innerHTML = itemsHtml;
            } else if (question.問題文) {
                domElements.questionTextDiv.innerHTML = question.問題文.replace(/\n/g, '<br>');
            } else {
                domElements.questionTextDiv.textContent = '問題文の形式が不明です。';
            }


            // 選択肢表示
            const isReviewingIncorrect = quizState.previousScreen === 'review_incorrect';
            // quizState.answered は、ランダム/年度別では解答時にtrueに、レビューでは常にtrue
            const disableOptions = quizState.answered || isReviewingIncorrect;
            domElements.optionsContainer.classList.toggle('answered', disableOptions);

            if (question.選択肢) {
                question.選択肢.forEach((optionText, index) => {
                    const label = document.createElement('label');
                    label.className = 'option-label';
                    const input = document.createElement('input');
                    input.type = 'radio';
                    input.name = 'answer';
                    input.value = (index + 1).toString();
                    const span = document.createElement('span');
                    span.className = 'option-text-span';
                    span.textContent = `${index + 1}. ${optionText}`;
                    label.appendChild(input);
                    label.appendChild(span);
                    domElements.optionsContainer.appendChild(label);

                    input.disabled = disableOptions;
                    if (disableOptions && question.userChoice && input.value === question.userChoice) {
                        input.checked = true; // ユーザーの選択を復元
                    }
                    if (!disableOptions) { // 解答可能状態の場合のみイベントリスナーを設定
                        input.addEventListener('change', handleOptionSelect);
                    }
                });
            }

            // 結果表示とスタイル適用 (解答済みまたはレビュー中の場合)
            if (disableOptions) { // quizState.answered が true またはレビュー中
                if (question.hasOwnProperty('userChoice') && question.hasOwnProperty('正解')) {
                     applyAnswerStylesAndResult(question.userChoice, question.正解, question);
                } else if (isReviewingIncorrect) {
                    // レビュー中で万が一 userChoice がない場合 (基本的にはありえないが念のため)
                    console.warn("Reviewing incorrect question without userChoice. Displaying correct answer only.");
                    applyAnswerStylesAndResult(null, question.正解, question); // 正解のみ表示
                }
            }

            // ボタン表示制御
            if (isReviewingIncorrect) {
                domElements.backToPreviousScreenButton.textContent = 'クイズ終了に戻る';
                domElements.backToPreviousScreenButton.style.display = 'inline-block';
                console.log("Displaying 'クイズ終了に戻る' button for review_incorrect.");
            } else if (quizState.answered) { // ランダムクイズまたは年度別クイズで解答済み
                if (quizState.previousScreen === 'random_setup') {
                    domElements.nextButton.style.display = 'block';
                    domElements.nextButton.textContent = (quizState.currentQuestionIndex < quizState.questions.length - 1) ? '次の問題へ' : '結果を見る';
                } else if (quizState.previousScreen === 'question_list') {
                    domElements.backToPreviousScreenButton.textContent = '問題一覧に戻る';
                    domElements.backToPreviousScreenButton.style.display = 'inline-block';
                    if (quizState.currentQuestionIndex < quizState.questions.length - 1) {
                        domElements.nextButton.style.display = 'inline-block';
                        domElements.nextButton.textContent = '次の問題へ';
                    }
                }
            }
            // 未解答時はボタンは表示されない (handleOptionSelect で表示される)
        }

        // ランダムクイズまたは年度別クイズの次の問題へ
        function loadNextQuestion() {
            console.log(`loadNextQuestion called. prevScreen=${quizState.previousScreen}`);
            quizState.answered = false; // 新しい問題なので未解答に
            if(domElements.optionsContainer) domElements.optionsContainer.classList.remove('answered');
            quizState.currentQuestionIndex++;

            if (domElements.resultDiv) {
                domElements.resultDiv.textContent = '';
                domElements.resultDiv.className = 'result';
            }
            if (domElements.nextButton) domElements.nextButton.style.display = 'none';
            if (domElements.backToPreviousScreenButton) domElements.backToPreviousScreenButton.style.display = 'none';


            if (quizState.previousScreen === 'random_setup') { // ランダムクイズの場合のみプログレスバー更新
                 if (domElements.progressBarContainer) domElements.progressBarContainer.style.display = 'block';
                 if (domElements.progressBar && quizState.questions.length > 0) {
                    const progress = ((quizState.currentQuestionIndex) / quizState.questions.length) * 100;
                    domElements.progressBar.style.width = `${progress}%`;
                 }
            }


            if (quizState.currentQuestionIndex < quizState.questions.length) {
                const currentQuestion = quizState.questions[quizState.currentQuestionIndex];
                // currentQuestion.userChoice と isCorrect は、ランダムクイズなら startRandomQuiz でクリア済み、
                // 年度別なら元々保持しているか、handleOptionSelect で設定される。ここでは何もしない。
                displayQuestion(currentQuestion);
                // showScreen('quiz') は displayQuestion の後、または startSpecificQuestionQuiz で呼ばれる
            } else { // 現在のリストの全問題を解き終わった場合
                if (quizState.previousScreen === 'random_setup') { // ランダムクイズ終了
                    if (domElements.progressBar) domElements.progressBar.style.width = `100%`;
                    quizState.previousScreen = 'end_random'; // 結果画面からの戻る先を示すため
                    showScreen('end', 'loadNextQuestion -> random_end');
                    if (domElements.finalScore) domElements.finalScore.textContent = `正答数: ${quizState.correctAnswers} / ${quizState.questions.length}`;
                    if (domElements.resetButton) domElements.resetButton.style.display = 'block';
                    displayIncorrectQuestions();
                } else if (quizState.previousScreen === 'question_list') { // 年度別クイズのリスト終了
                    // 年度内の最後の問題だった場合は問題一覧に戻る
                    if (quizState.currentYear) {
                        showQuestionList(quizState.currentYear); // currentMode は 'question_list' になる
                    } else {
                        showYearSelection(); // 万が一 currentYear がない場合
                    }
                }
            }
        }


        function handleOptionSelect(event) {
            console.log(`handleOptionSelect. prevScreen=${quizState.previousScreen}`);
            if (quizState.answered) return; // 既に回答済みなら何もしない (レビュー中は選択不可なのでここには来ないはず)

            const currentQuestion = quizState.currentQuestionObject;
            if (!currentQuestion) { console.error("handleOptionSelect: currentQuestionObject is null"); return; }

            quizState.answered = true; // これで解答済みになる
            domElements.optionsContainer.classList.add('answered');

            const selectedValue = event.target.value;
            const correctAnswer = currentQuestion.正解;
            currentQuestion.userChoice = selectedValue;
            currentQuestion.isCorrect = (selectedValue === correctAnswer);

            applyAnswerStylesAndResult(selectedValue, correctAnswer, currentQuestion);

            // ボタン表示 (displayQuestion と同じロジック)
            if (quizState.previousScreen === 'random_setup') {
                domElements.nextButton.style.display = 'block';
                domElements.nextButton.textContent = (quizState.currentQuestionIndex < quizState.questions.length - 1) ? '次の問題へ' : '結果を見る';
            } else if (quizState.previousScreen === 'question_list') {
                domElements.backToPreviousScreenButton.textContent = '問題一覧に戻る';
                domElements.backToPreviousScreenButton.style.display = 'inline-block';
                if (quizState.currentQuestionIndex < quizState.questions.length - 1) {
                    domElements.nextButton.style.display = 'inline-block';
                    domElements.nextButton.textContent = '次の問題へ';
                }
            }
        }

        function applyAnswerStylesAndResult(selectedValue, correctAnswer, questionObject) {
            // console.log(`applyAnswerStylesAndResult for ${questionObject.年度}-${questionObject.問題番号}, selected=${selectedValue}, correct=${correctAnswer}`);
            if (!domElements.optionsContainer || !domElements.resultDiv) return;

            domElements.optionsContainer.querySelectorAll('input[type="radio"]').forEach(radio => {
                radio.disabled = true; // 解答後は常に無効
                const label = radio.parentElement;
                if (label) {
                    label.style.cursor = 'default';
                    const optionValue = radio.value;
                    if (optionValue === correctAnswer) {
                        label.classList.add('correct-answer');
                        const span = label.querySelector('.option-text-span');
                        if (span && !span.textContent.startsWith('✅')) span.textContent = '✅ ' + span.textContent;
                    }
                    // selectedValue が null の場合 (レビューで解答履歴なしのケースなど) は不正解表示をスキップ
                    if (selectedValue && optionValue === selectedValue && selectedValue !== correctAnswer) {
                        label.classList.add('incorrect-answer');
                    }
                }
            });

            if (selectedValue && selectedValue === correctAnswer) { // 正解した場合
                domElements.resultDiv.textContent = '正解です！';
                domElements.resultDiv.className = 'result correct';
                if (quizState.previousScreen === 'random_setup' && questionObject.isCorrect === true && !quizState.incorrectQuestions.includes(questionObject)) {
                    // isCorrect が true になった時だけカウント (重複カウント防止のため answered フラグではなく)
                    // ただし、この関数は isCorrect 設定後なので、問題ないはず
                     if(questionObject.justMarkedCorrectNow) { // handleOptionSelect で正解になったばかり
                        quizState.correctAnswers++;
                        delete questionObject.justMarkedCorrectNow;
                     } else if (questionObject.isCorrect && !questionObject.hasOwnProperty('userChoiceBeforeApply')) {
                        // displayQuestion で解答済みを復元した場合、かつ初回の復元
                        // このロジックは複雑なので、correctAnswers は handleOptionSelect での正解時のみカウントがシンプル
                     }
                }
            } else if (selectedValue) { // 不正解の場合 (何かしら選択はされている)
                domElements.resultDiv.textContent = `不正解です。正解は ${correctAnswer} です。`;
                domElements.resultDiv.className = 'result incorrect';
                // 間違えた問題リストへの追加は、ランダムモードで、かつ handleOptionSelect で isCorrect が false になった直後
                // ここでは表示のみ
            } else if (!selectedValue && correctAnswer) { // 選択なしで正解のみ表示する場合 (レビュー時など)
                 domElements.resultDiv.textContent = `正解は ${correctAnswer} です。`;
                 domElements.resultDiv.className = 'result correct'; // 正解と同じスタイルで
            }


            // 正誤カウントと間違えた問題リストへの追加は handleOptionSelect で行うのが一貫性がある
            if (quizState.previousScreen === 'random_setup' && questionObject.isCorrect === true) {
                // quizState.correctAnswers++; // applyAnswerStylesAndResult は表示更新なのでここではない
            } else if (quizState.previousScreen === 'random_setup' && questionObject.isCorrect === false) {
                // if (!quizState.incorrectQuestions.find(q => q.問題番号 === questionObject.問題番号 && q.年度 === questionObject.年度)) {
                //     quizState.incorrectQuestions.push(questionObject); // ここでもない
                // }
            }
        }


        function handleNextButton() {
            console.log(`handleNextButton. prevScreen=${quizState.previousScreen}, currentQIdx=${quizState.currentQuestionIndex}, totalQs=${quizState.questions.length}`);
            // このボタンはランダムクイズか年度別クイズの解答後に表示される
            if (quizState.previousScreen === 'random_setup' || quizState.previousScreen === 'question_list') {
                loadNextQuestion();
            } else {
                console.warn("handleNextButton called from unexpected screen:", quizState.previousScreen);
            }
        }

        function displayIncorrectQuestions() {
            console.log("displayIncorrectQuestions. Count:", quizState.incorrectQuestions.length);
            if (!domElements.incorrectListContainer) return;
            domElements.incorrectListContainer.innerHTML = '';

            if (quizState.incorrectQuestions.length > 0) {
                const title = document.createElement('h3');
                title.className = 'text-xl text-red-700 mb-4';
                title.textContent = '間違えた問題';
                domElements.incorrectListContainer.appendChild(title);
                const ul = document.createElement('ul');
                ul.id = 'incorrect-list';
                quizState.incorrectQuestions.forEach((question) => {
                    const li = document.createElement('li');
                    let qText = question.問題文 ? question.問題文.substring(0,30)+'...' : (question.問題項目 ? '表形式問題' : '問題文なし');
                    if (question.問題文 && question.問題文.length <= 30) qText = question.問題文;
                    li.innerHTML = `<strong>${question.年度} ${question.問題番号}</strong>: ${qText}`;
                    li.addEventListener('click', () => {
                        // 間違えた問題リストからクリックされた場合
                        startSpecificQuestionQuiz(question, 'review_incorrect');
                    });
                    ul.appendChild(li);
                });
                domElements.incorrectListContainer.appendChild(ul);
            } else {
                domElements.incorrectListContainer.innerHTML = '<p class="text-lg text-green-700">素晴らしい！全問正解です！</p>';
            }
        }

        function returnToPreviousScreen() {
            console.log(`returnToPreviousScreen. currentMode=${quizState.currentMode}, prevScreen=${quizState.previousScreen}`);
            const screenToReturnTo = quizState.previousScreen; // 戻るべき画面を保持

            // UIリセット (ボタン、プログレスバー等)
            if (domElements.nextButton) domElements.nextButton.style.display = 'none';
            if (domElements.backToPreviousScreenButton) domElements.backToPreviousScreenButton.style.display = 'none';
            if (domElements.progressBarContainer) domElements.progressBarContainer.style.display = 'none';
            if (domElements.progressBar) domElements.progressBar.style.width = '0%';
            if (domElements.questionCountSpan) domElements.questionCountSpan.style.display = 'none';
            if (domElements.optionsContainer) domElements.optionsContainer.classList.remove('answered');
            if (domElements.resultDiv) { domElements.resultDiv.textContent = ''; domElements.resultDiv.className = 'result';}

            if (screenToReturnTo === 'question_list' && quizState.currentYear) {
                // currentMode は showQuestionList の中で 'question_list' に設定される
                // previousScreen は showQuestionList の中で 'year_select' に設定される
                showQuestionList(quizState.currentYear);
            } else if (screenToReturnTo === 'review_incorrect') { // 間違えた問題レビュー画面から「クイズ終了画面」へ
                quizState.previousScreen = 'end_random'; // さらに戻る場合のため
                showScreen('end', 'returnToPreviousScreen -> from review_incorrect');
                if (domElements.finalScore) domElements.finalScore.textContent = `正答数: ${quizState.correctAnswers} / ${NUMBER_OF_QUESTIONS_TO_ASK_RANDOM}`; // ランダムクイズの前提
                if (domElements.resetButton) domElements.resetButton.style.display = 'block';
                displayIncorrectQuestions(); // 間違えた問題リストを再表示
            } else if (screenToReturnTo === 'year_select') {
                showYearSelection();
            } else if (screenToReturnTo === 'random_setup') { // ランダムクイズ中に「戻る」はない想定だが、万が一のため
                showModeSelection();
            } else if (screenToReturnTo === 'end_random') { // クイズ終了画面から「戻る」 (通常はリセットボタン)
                 showModeSelection();
            }
            else { // デフォルトはモード選択へ
                showModeSelection();
            }
        }

        function showModeSelection() {
            console.log("showModeSelection called");
            quizState = { // quizStateを初期状態にリセット
                currentMode: 'select', questions: [], currentQuestionIndex: -1,
                currentQuestionObject: null, correctAnswers: 0, incorrectQuestions: [],
                answered: false, currentYear: null, previousScreen: 'select' // 初期状態
            };
            allQuizData.forEach(q => { delete q.userChoice; delete q.isCorrect; }); // 全データの解答履歴もクリア
            showScreen('select', 'showModeSelection');
            // 各コンテナの内容クリア (省略、変更なし)
            if (domElements.yearButtonsContainer) domElements.yearButtonsContainer.innerHTML = '';
            if (domElements.questionsForYearContainer) domElements.questionsForYearContainer.innerHTML = '';
            if (domElements.incorrectListContainer) domElements.incorrectListContainer.innerHTML = '';
            if (domElements.resultDiv) domElements.resultDiv.textContent = '';
            if (domElements.finalScore) domElements.finalScore.textContent = '';
            if (domElements.questionTitle) domElements.questionTitle.textContent = '';
            if (domElements.questionTextDiv) domElements.questionTextDiv.innerHTML = '';
            if (domElements.optionsContainer) domElements.optionsContainer.innerHTML = '';
            if (domElements.nextButton) domElements.nextButton.style.display = 'none';
            if (domElements.backToPreviousScreenButton) domElements.backToPreviousScreenButton.style.display = 'none';
            if (domElements.resetButton) domElements.resetButton.style.display = 'none';
            if (domElements.progressBarContainer) domElements.progressBarContainer.style.display = 'none';
            if (domElements.progressBar) domElements.progressBar.style.width = '0%';
            if (domElements.questionCountSpan) domElements.questionCountSpan.style.display = 'none';
        }

        function resetQuiz() { // 「もう一度挑戦する」ボタン
            console.log("resetQuiz called");
            showModeSelection(); // モード選択画面に戻り、状態を完全にリセット
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded: Caching DOM elements and loading quiz data.");
            cacheDOMElements();
            loadQuizData(); // この中で initializeQuiz() が呼ばれる
        });
    </script>

</body>
</html>
